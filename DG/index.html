<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duelo de Piadas</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(45deg, #2c1810, #4a2c1a, #1a2a40);
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
            user-select: none;
            image-rendering: pixelated;
            touch-action: manipulation;
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        @media (max-width: 768px) {
            .game-container {
                height: 100dvh; /* Dynamic viewport height para mobile */
            }
        }

        .vs-bar {
            background: linear-gradient(90deg, #8B0000, #DC143C, #8B0000);
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            border-bottom: 3px solid #000;
            margin-bottom: 60px;
        }

        @media (max-width: 768px) {
            .vs-bar {
                height: 50px;
                margin-bottom: 40px;
            }
        }

        .vs-circle {
            background: #FFD700;
            border: 3px solid #000;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            z-index: 10;
        }

        @media (max-width: 768px) {
            .vs-circle {
                width: 40px;
                height: 40px;
                font-size: 10px;
                border: 2px solid #000;
            }
        }

        .health-bar {
            position: absolute;
            top: 15px;
            height: 30px;
            background: #333;
            border: 2px solid #000;
            border-radius: 0;
            overflow: hidden;
        }

        .health-bar.left {
            right: 50%;
            margin-right: 25px;
            width: 200px;
        }

        .health-bar.right {
            left: 50%;
            margin-left: 25px;
            width: 200px;
        }

        @media (max-width: 768px) {
            .health-bar {
                height: 20px;
                top: 10px;
            }

            .health-bar.left {
                width: 150px;
                margin-right: 20px;
            }

            .health-bar.right {
                width: 150px;
                margin-left: 20px;
            }
        }

        @media (max-width: 480px) {
            .health-bar.left {
                width: 100px;
                margin-right: 15px;
            }

            .health-bar.right {
                width: 100px;
                margin-left: 15px;
            }
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff4444);
            transition: width 0.5s ease;
            border-radius: 0;
        }

        .health-fill.player {
            transform-origin: left;
        }

        .health-fill.opponent {
            transform-origin: right;
            margin-left: auto;
        }

        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 8px;
            text-shadow: 1px 1px 2px black;
        }

        @media (max-width: 768px) {
            .health-text {
                font-size: 6px;
            }
        }

        .battle-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            position: relative;
            background: 
                radial-gradient(circle at 30% 70%, rgba(139, 69, 19, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 70% 30%, rgba(75, 0, 130, 0.2) 0%, transparent 50%);
        }

        .character {
            width: 120px;
            height: 180px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s ease;
            position: absolute;
        }

        .character.player {
            left: 25%;
            transform: translateX(-50%);
        }

        .character.opponent {
            right: 25%;
            transform: translateX(50%);
        }

        @media (max-width: 768px) {
            .character {
                width: 80px;
                height: 120px;
                transform: scale(0.7);
            }

            .character.player {
                left: 15%;
            }

            .character.opponent {
                right: 15%;
            }
        }

        @media (max-width: 480px) {
            .character {
                transform: scale(0.5);
            }

            .character.player {
                left: 10%;
            }

            .character.opponent {
                right: 10%;
            }
        }

        .pixel-character {
            width: 80px;
            height: 120px;
            position: relative;
            image-rendering: pixelated;
        }

        /* Cabe√ßa */
        .char-head {
            width: 32px;
            height: 32px;
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Cabelo */
        .char-hair {
            width: 36px;
            height: 16px;
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 8px 8px 0 0;
        }

        /* Olhos */
        .char-eyes {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
        }

        .char-eye {
            width: 6px;
            height: 6px;
            background: #000;
            border-radius: 1px;
        }

        /* Boca */
        .char-mouth {
            width: 12px;
            height: 4px;
            background: #000;
            position: absolute;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 0 0 4px 4px;
        }

        /* Corpo */
        .char-body {
            width: 28px;
            height: 32px;
            position: absolute;
            top: 36px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
        }

        /* Bra√ßos */
        .char-arms {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 48px;
            display: flex;
            justify-content: space-between;
        }

        .char-arm {
            width: 8px;
            height: 28px;
            border-radius: 2px;
        }

        /* Pernas */
        .char-legs {
            position: absolute;
            top: 72px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
        }

        .char-leg {
            width: 10px;
            height: 32px;
            border-radius: 0 0 2px 2px;
        }

        /* Sapatos */
        .char-shoes {
            position: absolute;
            bottom: 0;
            width: 14px;
            height: 8px;
            background: #2c1810;
            border-radius: 0 0 3px 3px;
        }

        .character-label {
            margin-top: 10px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 2px black;
            font-size: 6px;
        }

        @media (max-width: 768px) {
            .character-label {
                font-size: 5px;
            }
        }

        .opponent.damaged {
            animation: damage-shake 0.5s ease-in-out;
            filter: brightness(0.7) contrast(1.2) hue-rotate(180deg);
        }

        .player.damaged {
            animation: damage-shake 0.5s ease-in-out;
            filter: brightness(0.7) contrast(1.2) hue-rotate(180deg);
        }

        @keyframes damage-shake {
            0%, 100% { transform: translateX(-50%); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(calc(-50% - 10px)) rotate(-2deg); }
            20%, 40%, 60%, 80% { transform: translateX(calc(-50% + 10px)) rotate(2deg); }
        }

        .combo-area {
            position: absolute;
            top: 70%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 10px;
            min-height: 120px;
            align-items: center;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 15px;
            border: 2px dashed #FFD700;
        }

        @media (max-width: 768px) {
            .combo-area {
                top: 65%;
                gap: 5px;
                padding: 10px;
                min-height: 80px;
                overflow-x: auto;
                max-width: 90vw;
            }
        }

        @media (max-width: 480px) {
            .combo-area {
                top: 60%;
                padding: 8px;
                gap: 3px;
            }
        }

        .combo-slot {
            width: 80px;
            height: 110px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.1);
            transition: all 0.3s ease;
            position: relative;
        }

        @media (max-width: 768px) {
            .combo-slot {
                width: 50px;
                height: 70px;
                flex-shrink: 0;
            }
        }

        @media (max-width: 480px) {
            .combo-slot {
                width: 45px;
                height: 65px;
            }
        }

        .combo-slot.filled {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }

        .combo-slot.connected::after {
            content: '‚Üí';
            position: absolute;
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
            color: #00ff00;
            font-size: 14px;
            text-shadow: 0 0 10px rgba(0,255,0,0.8);
        }

        .hand-area {
            height: 150px;
            background: linear-gradient(to top, #1a1a1a, transparent);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 30px 20px 20px 20px;
            position: relative;
        }

        @media (max-width: 768px) {
            .hand-area {
                height: 120px;
                padding: 20px 10px 10px 10px;
                gap: 5px;
                overflow-x: auto;
                justify-content: flex-start;
            }
        }

        @media (max-width: 480px) {
            .hand-area {
                height: 110px;
                padding: 15px 5px 5px 5px;
                gap: 3px;
            }
        }

        .deck-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-left: 15px;
        }

        @media (max-width: 768px) {
            .deck-area {
                margin-left: 8px;
                gap: 3px;
            }
        }

        @media (max-width: 480px) {
            .deck-area {
                margin-left: 5px;
            }
        }

        .deck-pile {
            width: 23px;
            height: 33px;
            border: 2px solid #000;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            color: white;
            text-shadow: 1px 1px 1px black;
            background: linear-gradient(145deg, #654321, #8B4513);
        }

        .deck-label {
            font-size: 5px;
            color: #FFD700;
            text-shadow: 1px 1px 1px black;
            font-weight: bold;
            text-align: center;
        }

        @media (max-width: 768px) {
            .deck-pile {
                width: 18px;
                height: 26px;
                font-size: 6px;
            }

            .deck-label {
                font-size: 4px;
            }
        }

        @media (max-width: 480px) {
            .deck-pile {
                width: 16px;
                height: 23px;
                font-size: 5px;
            }

            .deck-label {
                font-size: 3px;
            }
        }

        .card {
            width: 70px;
            height: 100px;
            background: linear-gradient(145deg, #f0f0f0, #d0d0d0);
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            position: relative;
        }

        @media (max-width: 768px) {
            .card {
                width: 50px;
                height: 70px;
                flex-shrink: 0;
            }
        }

        @media (max-width: 480px) {
            .card {
                width: 45px;
                height: 65px;
            }
        }

        .card:hover {
            transform: translateY(-10px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
        }

        .card.selected {
            transform: translateY(-20px);
            border-color: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
        }

        .card.in-combo {
            transform: scale(0.9);
            opacity: 0.7;
        }

        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(80%);
        }

        .card.disabled:hover {
            transform: translateY(0);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .card.invalid-move {
            animation: invalid-shake 0.4s ease-in-out;
            border-color: #ff0000 !important;
        }

        @keyframes invalid-shake {
            0%, 100% { 
                transform: translateY(-10px) scale(1);
                filter: brightness(1);
            }
            25% { 
                transform: translateY(-10px) scale(1.05) rotate(-2deg);
                filter: brightness(1.5) hue-rotate(-30deg);
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            }
            75% { 
                transform: translateY(-10px) scale(1.05) rotate(2deg);
                filter: brightness(1.5) hue-rotate(-30deg);
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            }
        }

        .card-symbols {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 0 8px;
            margin-bottom: 8px;
        }

        .card-symbol {
            font-size: 20px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        @media (max-width: 768px) {
            .card-symbol {
                font-size: 14px;
            }
        }

        @media (max-width: 480px) {
            .card-symbol {
                font-size: 12px;
            }
        }

        .card-symbol.circle { color: #ff4444; }
        .card-symbol.triangle { color: #22cc22; }
        .card-symbol.square { color: #4444ff; }
        .card-symbol.diamond { color: #ff8800; }
        .card-symbol.lines { color: #8844ff; }

        .card-divider {
            width: 1px;
            height: 30px;
            background: #666;
        }

        .card-text {
            font-size: 6px;
            text-align: center;
            padding: 2px;
            color: #333;
        }

        @media (max-width: 768px) {
            .card-text {
                font-size: 4px;
                padding: 1px;
            }
        }

        @media (max-width: 480px) {
            .card-text {
                font-size: 3px;
            }
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        @media (max-width: 768px) {
            .controls {
                bottom: 5px;
                gap: 5px;
                flex-wrap: wrap;
                justify-content: center;
                max-width: 95vw;
            }
        }

        .btn {
            padding: 10px 20px;
            background: linear-gradient(145deg, #4CAF50, #45a049);
            border: 2px solid #000;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            font-size: 8px;
            font-family: 'Press Start 2P', monospace;
        }

        @media (max-width: 768px) {
            .btn {
                padding: 8px 12px;
                font-size: 6px;
            }
        }

        @media (max-width: 480px) {
            .btn {
                padding: 6px 10px;
                font-size: 5px;
            }
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .damage-text {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            color: #ff4444;
            text-shadow: 2px 2px 4px black;
            pointer-events: none;
            z-index: 1000;
            font-family: 'Press Start 2P', monospace;
        }

        .floating-damage {
            animation: float-up 1s ease-out forwards;
        }

        @keyframes float-up {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px);
            }
        }

        .sequence-indicator {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 20px;
            height: 20px;
            background: #4CAF50;
            border-radius: 50%;
            color: white;
            font-size: 8px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #000;
        }

        .joke-display {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #FFD700;
            border-radius: 10px;
            padding: 15px 25px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: none;
        }

        @media (max-width: 768px) {
            .joke-display {
                top: 50px;
                padding: 10px 15px;
                max-width: 85vw;
                border: 2px solid #FFD700;
            }
        }

        @media (max-width: 480px) {
            .joke-display {
                top: 45px;
                padding: 8px 12px;
                max-width: 90vw;
            }
        }

        .joke-display.active {
            display: block;
            animation: joke-appear 0.5s ease-out;
        }

        @keyframes joke-appear {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
            100% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .joke-text {
            color: #FFD700;
            font-size: 10px;
            line-height: 1.6;
            text-shadow: 2px 2px 2px black;
            margin: 0;
        }

        .joke-level {
            color: #ff4444;
            font-size: 8px;
            margin-bottom: 8px;
            text-shadow: 1px 1px 1px black;
        }

        @media (max-width: 768px) {
            .joke-text {
                font-size: 7px;
                line-height: 1.4;
            }

            .joke-level {
                font-size: 6px;
                margin-bottom: 5px;
            }
        }

        @media (max-width: 480px) {
            .joke-text {
                font-size: 6px;
            }

            .joke-level {
                font-size: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Barra VS com vida -->
        <div class="vs-bar">
            <div class="health-bar left">
                <div class="health-fill player" id="playerHealth" style="width: 100%"></div>
                <div class="health-text" id="playerHealthText">100/100</div>
            </div>
            <div class="vs-circle">VS</div>
            <div class="health-bar right">
                <div class="health-fill opponent" id="opponentHealth" style="width: 100%"></div>
                <div class="health-text" id="opponentHealthText">100/100</div>
            </div>
            
            <!-- Display de piadas -->
            <div class="joke-display" id="jokeDisplay">
                <div class="joke-level" id="jokeLevel"></div>
                <p class="joke-text" id="jokeText"></p>
            </div>
        </div>

        <!-- √Årea de batalha -->
        <div class="battle-area">
            <!-- Jogador -->
            <div class="character player">
                <div class="character-head"></div>
                <div class="character-arms"></div>
                <div class="character-body"></div>
                <div class="character-legs">
                    <div class="character-leg"></div>
                    <div class="character-leg"></div>
                </div>
                <div class="character-label">VOC√ä</div>
            </div>

            <!-- √Årea de combo no centro -->
            <div class="combo-area" id="comboArea">
                <div class="combo-slot" data-slot="0"></div>
                <div class="combo-slot" data-slot="1"></div>
                <div class="combo-slot" data-slot="2"></div>
                <div class="combo-slot" data-slot="3"></div>
                <div class="combo-slot" data-slot="4"></div>
            </div>

            <!-- Oponente -->
            <div class="character opponent" id="opponent">
                <div class="character-head"></div>
                <div class="character-arms"></div>
                <div class="character-body"></div>
                <div class="character-legs">
                    <div class="character-leg"></div>
                    <div class="character-leg"></div>
                </div>
                <div class="character-label">OPONENTE</div>
            </div>
        </div>

        <!-- √Årea das cartas na m√£o -->
        <div class="hand-area" id="handArea">
            <!-- √Årea de baralho -->
            <div class="deck-area">
                <div class="deck-pile" id="deckCounter">43</div>
                <div class="deck-label">BARALHO</div>
            </div>
        </div>

        <!-- Controles -->
        <div class="controls">
            <button class="btn" id="playComboBtn" disabled>ATACAR!</button>
            <button class="btn" id="clearComboBtn">LIMPAR</button>
            <button class="btn" id="newHandBtn">NOVA M√ÉO</button>
        </div>
    </div>

    <script>
        // Estado do jogo
        let gameState = {
            playerHealth: 100,
            opponentHealth: 100,
            hand: [],
            combo: [],
            selectedCard: null,
            deckCount: 43, // 50 cartas - 7 iniciais = 43
            playerCharacter: null,
            opponentCharacter: null,
            isPlayerTurn: true // Controla de quem √© o turno
        };

        // Configura√ß√µes de personagens aleat√≥rios
        const characterStyles = {
            skinTones: ['#FDBCB4', '#F1C27D', '#E0AC69', '#C68642', '#8D5524'],
            hairColors: ['#2c1810', '#654321', '#8B4513', '#D2691E', '#FFD700', '#FF6347', '#4B0082'],
            shirtColors: ['#FF4444', '#4444FF', '#44FF44', '#FF44FF', '#FFFF44', '#FF8844', '#8844FF'],
            pantsColors: ['#2c3e50', '#34495e', '#16a085', '#27ae60', '#8e44ad', '#2980b9'],
            hairStyles: ['flat', 'spiky', 'curly', 'mohawk']
        };

        function generateRandomCharacter() {
            return {
                skin: characterStyles.skinTones[Math.floor(Math.random() * characterStyles.skinTones.length)],
                hair: characterStyles.hairColors[Math.floor(Math.random() * characterStyles.hairColors.length)],
                shirt: characterStyles.shirtColors[Math.floor(Math.random() * characterStyles.shirtColors.length)],
                pants: characterStyles.pantsColors[Math.floor(Math.random() * characterStyles.pantsColors.length)],
                hairStyle: characterStyles.hairStyles[Math.floor(Math.random() * characterStyles.hairStyles.length)]
            };
        }

        function createCharacterHTML(char, isPlayer) {
            let hairClass = '';
            let hairTop = '-8px';
            
            switch(char.hairStyle) {
                case 'spiky':
                    hairClass = 'style="border-radius: 0; clip-path: polygon(0% 50%, 20% 0%, 40% 50%, 60% 0%, 80% 50%, 100% 0%, 100% 100%, 0% 100%);"';
                    hairTop = '-12px';
                    break;
                case 'curly':
                    hairClass = 'style="border-radius: 50%; height: 20px;"';
                    hairTop = '-10px';
                    break;
                case 'mohawk':
                    hairClass = 'style="width: 16px; height: 24px; border-radius: 8px 8px 0 0; left: 50%; transform: translateX(-50%);"';
                    hairTop = '-16px';
                    break;
                default:
                    hairClass = 'style="border-radius: 8px 8px 0 0;"';
            }
            
            return `
                <div class="pixel-character">
                    <div class="char-hair" style="background: ${char.hair}; top: ${hairTop};" ${hairClass}></div>
                    <div class="char-head" style="background: ${char.skin}; border: 2px solid #000; border-radius: 4px;">
                        <div class="char-eyes">
                            <div class="char-eye"></div>
                            <div class="char-eye"></div>
                        </div>
                        <div class="char-mouth"></div>
                    </div>
                    <div class="char-body" style="background: ${char.shirt}; border: 2px solid #000;"></div>
                    <div class="char-arms">
                        <div class="char-arm" style="background: ${char.skin}; border: 2px solid #000;"></div>
                        <div class="char-arm" style="background: ${char.skin}; border: 2px solid #000;"></div>
                    </div>
                    <div class="char-legs">
                        <div class="char-leg" style="background: ${char.pants}; border: 2px solid #000; position: relative;">
                            <div class="char-shoes"></div>
                        </div>
                        <div class="char-leg" style="background: ${char.pants}; border: 2px solid #000; position: relative;">
                            <div class="char-shoes"></div>
                        </div>
                    </div>
                </div>
                <div class="character-label">${isPlayer ? 'VOC√ä' : 'OPONENTE'}</div>
            `;
        }

        // S√≠mbolos dispon√≠veis
        const symbols = ['‚óã', '‚ñ≥', '‚ñ°', '‚óá', '||'];

        // Base de piadas por s√≠mbolo e n√≠vel
        const jokes = {
            '‚óã': { // C√≠rculo - Piadas de gordo
                category: 'PIADAS DE GORDO',
                levels: [
                    'Rolha de po√ßo.',
                    'Quando voc√™ pula, o Waze recalcula a rota.',
                    'Seu apelido deveria ser DLC: sempre vem com peso extra.',
                    'Quando voc√™ deita na praia, o mar sobe de n√≠vel.',
                    'Voc√™ √© t√£o gordo que quando muda o celular de bolso, ele precisa atualizar o GPS.'
                ]
            },
            '||': { // Linhas - Piadas de magro
                category: 'PIADAS DE MAGRO',
                levels: [
                    'Seu palito.',
                    'Se voc√™ virar de lado e colocar a l√≠ngua pra fora, parece um z√≠per.',
                    'Voc√™ √© t√£o magro que se tossir, desmonta.',
                    'Voc√™ √© t√£o magro que quando vai ao hospital, a enfermeira te pesa junto com a roupa pra dar resultado decente.',
                    'Voc√™ √© t√£o magro que no exame de raio-x, o m√©dico pediu para voc√™ virar de frente‚Ä¶ e voc√™ j√° estava.'
                ]
            },
            '‚ñ≥': { // Tri√¢ngulo - Piadas de pobre
                category: 'PIADAS DE POBRE',
                levels: [
                    'Seu pobre.',
                    'Voc√™ n√£o tem ventilador, tem tampa de caderno abanando.',
                    'Sua casa n√£o tem Wi-Fi, tem senha de vizinho.',
                    'Voc√™ √© t√£o pobre que sua √°rvore de Natal √© um cabo de vassoura.',
                    'Voc√™ √© t√£o pobre que quando entra no banco, a porta gira e devolve.'
                ]
            },
            '‚ñ°': { // Quadrado - Piadas de feio
                category: 'PIADAS DE FEIO',
                levels: [
                    'Seu feio.',
                    'Quando voc√™ sorri, o Wi-Fi cai.',
                    'Voc√™ √© t√£o feio que j√° participou de filme de terror sem maquiagem.',
                    'Seu reflexo no espelho te processou por dano moral.',
                    'Voc√™ √© t√£o feio que quando liga a c√¢mera do celular, o antiv√≠rus d√° aviso de perigo.'
                ]
            },
            '‚óá': { // Diamante - Piadas de burro
                category: 'PIADAS DE BURRO',
                levels: [
                    'Asno de plant√£o.',
                    'Se a burrice fosse esporte ol√≠mpico, voc√™ ganhava ouro.',
                    'Voc√™ √© t√£o burro que ficou na frente do ventilador esperando abrir o navegador.',
                    'Voc√™ √© t√£o burro que tentou passar o dedo na revista achando que era touchscreen.',
                    'Voc√™ √© t√£o burro que tentou colocar fermento no arroz pra render mais.'
                ]
            }
        };

        // Inicializar jogo
        function initGame() {
            // Gerar personagens aleat√≥rios
            gameState.playerCharacter = generateRandomCharacter();
            gameState.opponentCharacter = generateRandomCharacter();
            
            // Renderizar personagens
            document.querySelector('.character.player').innerHTML = createCharacterHTML(gameState.playerCharacter, true);
            document.querySelector('.character.opponent').innerHTML = createCharacterHTML(gameState.opponentCharacter, false);
            
            generateHand();
            updateUI();
            updateDeckDisplay();
        }

        // Atualizar display do baralho
        function updateDeckDisplay() {
            const deckCounter = document.getElementById('deckCounter');
            if (deckCounter) {
                deckCounter.textContent = gameState.deckCount;
            }
        }

        // Obter classe CSS do s√≠mbolo
        function getSymbolClass(symbol) {
            const symbolMap = {
                '‚óã': 'circle',
                '‚ñ≥': 'triangle',
                '‚ñ°': 'square',
                '‚óá': 'diamond',
                '||': 'lines'
            };
            return symbolMap[symbol] || 'circle';
        }

        // Gerar m√£o de cartas
        function generateHand() {
            gameState.hand = [];
            for (let i = 0; i < 7; i++) {
                const leftSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                const rightSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                gameState.hand.push({
                    id: i,
                    leftSymbol: leftSymbol,
                    rightSymbol: rightSymbol,
                    text: getCardText(leftSymbol, rightSymbol)
                });
            }
            renderHand();
        }

        // Texto das cartas baseado nos s√≠mbolos
        function getCardText(leftSymbol, rightSymbol) {
            const symbolNames = {
                '‚óã': 'GORDO',
                '‚ñ≥': 'POBRE',
                '‚ñ°': 'FEIO',
                '‚óá': 'BURRO',
                '||': 'MAGRO'
            };
            
            const leftText = symbolNames[leftSymbol] || '';
            const rightText = symbolNames[rightSymbol] || '';
            
            return `${leftText}/${rightText}`;
        }

        // Renderizar m√£o
        function renderHand() {
            const handArea = document.getElementById('handArea');
            
            // Limpar apenas as cartas, mantendo a √°rea do baralho
            const existingCards = handArea.querySelectorAll('.card');
            existingCards.forEach(card => card.remove());
            
            gameState.hand.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'card';
                cardElement.dataset.cardId = card.id;
                
                if (gameState.combo.includes(card.id)) {
                    cardElement.classList.add('in-combo');
                }
                
                // Adicionar classe disabled se n√£o for turno do jogador
                if (!gameState.isPlayerTurn) {
                    cardElement.classList.add('disabled');
                }
                
                cardElement.innerHTML = `
                    <div class="card-symbols">
                        <div class="card-symbol ${getSymbolClass(card.leftSymbol)}">${card.leftSymbol}</div>
                        <div class="card-divider"></div>
                        <div class="card-symbol ${getSymbolClass(card.rightSymbol)}">${card.rightSymbol}</div>
                    </div>
                    <div class="card-text">${card.text}</div>
                `;
                
                cardElement.addEventListener('click', () => selectCard(card, cardElement));
                handArea.appendChild(cardElement);
            });
        }

        // Selecionar carta
        function selectCard(card, cardElement) {
            // Bloquear se n√£o for turno do jogador
            if (!gameState.isPlayerTurn) {
                return;
            }
            
            if (gameState.combo.includes(card.id)) return;
            
            // Verificar se a carta pode ser adicionada ao combo (regra do domin√≥)
            if (gameState.combo.length > 0) {
                const lastCardId = gameState.combo[gameState.combo.length - 1];
                const lastCard = gameState.hand.find(c => c.id === lastCardId);
                
                // A carta s√≥ pode ser adicionada se o s√≠mbolo direito da √∫ltima carta
                // for igual ao s√≠mbolo esquerdo da carta atual
                if (lastCard && lastCard.rightSymbol !== card.leftSymbol) {
                    // Anima√ß√£o de movimento inv√°lido
                    cardElement.classList.add('invalid-move');
                    setTimeout(() => {
                        cardElement.classList.remove('invalid-move');
                    }, 400);
                    return;
                }
            }
            
            if (gameState.combo.length < 5) {
                gameState.combo.push(card.id);
                updateComboArea();
                renderHand();
                updatePlayButton();
            }
        }

        // Atualizar √°rea de combo
        function updateComboArea() {
            const slots = document.querySelectorAll('.combo-slot');
            slots.forEach((slot, index) => {
                slot.innerHTML = '';
                slot.classList.remove('filled', 'connected');
                
                if (gameState.combo[index] !== undefined) {
                    const cardId = gameState.combo[index];
                    const card = gameState.hand.find(c => c.id === cardId);
                    
                    if (card) {
                        slot.innerHTML = `
                            <div class="card-symbols">
                                <div class="card-symbol ${getSymbolClass(card.leftSymbol)}">${card.leftSymbol}</div>
                                <div class="card-divider"></div>
                                <div class="card-symbol ${getSymbolClass(card.rightSymbol)}">${card.rightSymbol}</div>
                            </div>
                            <div class="sequence-indicator">${index + 1}</div>
                        `;
                        slot.classList.add('filled');
                        
                        // Verificar conex√£o com pr√≥xima carta (sempre v√°lida agora devido √† valida√ß√£o pr√©via)
                        if (index < gameState.combo.length - 1) {
                            slot.classList.add('connected');
                        }
                    }
                }
            });
            
            // Atualizar piada baseada no combo
            updateJokeDisplay();
        }

        // Atualizar display da piada
        function updateJokeDisplay() {
            const jokeDisplay = document.getElementById('jokeDisplay');
            const jokeLevel = document.getElementById('jokeLevel');
            const jokeText = document.getElementById('jokeText');
            
            if (gameState.combo.length === 0) {
                jokeDisplay.classList.remove('active');
                return;
            }
            
            // Pegar o s√≠mbolo esquerdo da primeira carta do combo
            const firstCardId = gameState.combo[0];
            const firstCard = gameState.hand.find(c => c.id === firstCardId);
            
            if (firstCard && jokes[firstCard.leftSymbol]) {
                const jokeData = jokes[firstCard.leftSymbol];
                const level = gameState.combo.length; // N√≠vel de 1 a 5
                const jokeIndex = level - 1; // Array come√ßa em 0
                
                jokeLevel.textContent = `${jokeData.category} - N√çVEL ${level}`;
                jokeText.textContent = jokeData.levels[jokeIndex];
                jokeDisplay.classList.add('active');
            }
        }

        // Atualizar bot√£o de jogar
        function updatePlayButton() {
            const playBtn = document.getElementById('playComboBtn');
            const newHandBtn = document.getElementById('newHandBtn');
            
            // Desabilitar bot√µes se n√£o for turno do jogador
            if (!gameState.isPlayerTurn) {
                playBtn.disabled = true;
                newHandBtn.disabled = true;
            } else {
                playBtn.disabled = gameState.combo.length === 0;
                newHandBtn.disabled = gameState.combo.length > 0;
            }
        }

        // Calcular dano do combo
        function calculateDamage() {
            if (gameState.combo.length === 0) return 0;
            
            // Como agora todas as conex√µes s√£o sempre v√°lidas (devido √† valida√ß√£o pr√©via),
            // o c√°lculo fica mais simples
            const numCards = gameState.combo.length;
            const validConnections = Math.max(0, numCards - 1);
            
            // Calcular dano (reduzido em 1/3)
            let damage = numCards * 3; // Dano base por carta (era 5, agora 3)
            damage += validConnections * 10; // B√¥nus por conex√£o v√°lida (era 15, agora 10)
            
            // Super b√¥nus por combo perfeito (5 cartas todas conectadas)
            if (numCards === 5) {
                damage += 20; // B√¥nus reduzido (era 30, agora 20)
            }
            
            return Math.min(damage, gameState.opponentHealth);
        }

        // Verificar condi√ß√£o de derrota por falta de cartas
        function checkGameOver() {
            if (gameState.hand.length === 0 && gameState.deckCount === 0) {
                setTimeout(() => {
                    alert('GAME OVER! Voc√™ ficou sem cartas! üíÄ');
                    resetGame();
                }, 500);
                return true;
            }
            return false;
        }

        // Executar combo
        function playCombo() {
            const damage = calculateDamage();
            
            if (damage > 0) {
                // Bloquear turno do jogador
                gameState.isPlayerTurn = false;
                renderHand();
                updatePlayButton();
                
                // Aplicar dano
                gameState.opponentHealth = Math.max(0, gameState.opponentHealth - damage);
                
                // Anima√ß√£o de dano
                showDamage(damage);
                damageOpponent();
                
                // Remover cartas usadas
                const usedCards = gameState.combo.length;
                gameState.hand = gameState.hand.filter(card => !gameState.combo.includes(card.id));
                
                // Calcular quantas cartas novas s√£o necess√°rias
                const cardsNeeded = 7 - gameState.hand.length;
                const cardsToAdd = Math.min(cardsNeeded, gameState.deckCount);
                
                // Diminuir contador do baralho
                gameState.deckCount -= cardsToAdd;
                
                // Preencher m√£o
                for (let i = 0; i < cardsToAdd; i++) {
                    const leftSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                    const rightSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                    gameState.hand.push({
                        id: Date.now() + Math.random() + i,
                        leftSymbol: leftSymbol,
                        rightSymbol: rightSymbol,
                        text: getCardText(leftSymbol, rightSymbol)
                    });
                }
                
                updateDeckDisplay();
                
                setTimeout(() => {
                    if (gameState.opponentHealth <= 0) {
                        alert('VIT√ìRIA! üéâ');
                        resetGame();
                    } else if (!checkGameOver()) {
                        opponentTurn();
                    }
                }, 1500);
            }
            
            clearCombo();
        }

        // Mostrar dano
        function showDamage(damage) {
            const damageElement = document.createElement('div');
            damageElement.className = 'damage-text floating-damage';
            damageElement.textContent = `-${damage}`;
            damageElement.style.left = '70%';
            damageElement.style.top = '40%';
            
            document.body.appendChild(damageElement);
            
            setTimeout(() => {
                document.body.removeChild(damageElement);
            }, 1000);
        }

        // Animar dano no oponente
        function damageOpponent() {
            const opponent = document.getElementById('opponent');
            opponent.classList.add('damaged');
            
            setTimeout(() => {
                opponent.classList.remove('damaged');
            }, 500);
        }

        // Animar dano no jogador
        function damagePlayer() {
            const player = document.querySelector('.character.player');
            player.classList.add('damaged');
            
            setTimeout(() => {
                player.classList.remove('damaged');
            }, 500);
        }

        // Mostrar piada do oponente
        function showOpponentJoke() {
            const jokeDisplay = document.getElementById('jokeDisplay');
            const jokeLevel = document.getElementById('jokeLevel');
            const jokeText = document.getElementById('jokeText');
            
            // Escolher s√≠mbolo aleat√≥rio
            const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
            const jokeData = jokes[randomSymbol];
            
            // Escolher n√≠vel aleat√≥rio (1 a 5)
            const randomLevel = Math.floor(Math.random() * 5) + 1;
            const jokeIndex = randomLevel - 1;
            
            jokeLevel.textContent = `${jokeData.category} - N√çVEL ${randomLevel}`;
            jokeText.textContent = jokeData.levels[jokeIndex];
            jokeDisplay.classList.add('active');
            
            // Esconder piada ap√≥s 3 segundos
            setTimeout(() => {
                jokeDisplay.classList.remove('active');
            }, 3000);
        }

        // Turno do oponente
        function opponentTurn() {
            setTimeout(() => {
                const damage = Math.floor(Math.random() * 25) + 10;
                gameState.playerHealth = Math.max(0, gameState.playerHealth - damage);
                
                // Mostrar piada do oponente
                showOpponentJoke();
                
                // Animar dano no jogador
                damagePlayer();
                
                // Mostrar dano do oponente
                const damageElement = document.createElement('div');
                damageElement.className = 'damage-text floating-damage';
                damageElement.textContent = `-${damage}`;
                damageElement.style.left = '30%';
                damageElement.style.top = '40%';
                
                document.body.appendChild(damageElement);
                
                setTimeout(() => {
                    document.body.removeChild(damageElement);
                }, 1000);
                
                updateUI();
                
                if (gameState.playerHealth <= 0) {
                    setTimeout(() => {
                        alert('GAME OVER! üíÄ');
                        resetGame();
                    }, 2000);
                } else {
                    // Verificar se ainda tem cartas ap√≥s o turno do oponente
                    if (!checkGameOver()) {
                        // Devolver turno ao jogador ap√≥s 2 segundos
                        setTimeout(() => {
                            gameState.isPlayerTurn = true;
                            renderHand();
                            updatePlayButton();
                        }, 2000);
                    }
                }
            }, 1000);
        }

        // Limpar combo
        function clearCombo() {
            gameState.combo = [];
            updateComboArea();
            renderHand();
            updatePlayButton();
            
            // Esconder piada
            const jokeDisplay = document.getElementById('jokeDisplay');
            jokeDisplay.classList.remove('active');
        }

        // Resetar jogo
        function resetGame() {
            gameState.playerHealth = 100;
            gameState.opponentHealth = 100;
            gameState.combo = [];
            gameState.deckCount = 43; // Reset para 43 (50 - 7 iniciais)
            gameState.isPlayerTurn = true; // Jogador sempre come√ßa
            
            // Gerar novos personagens aleat√≥rios
            gameState.playerCharacter = generateRandomCharacter();
            gameState.opponentCharacter = generateRandomCharacter();
            
            // Renderizar novos personagens
            document.querySelector('.character.player').innerHTML = createCharacterHTML(gameState.playerCharacter, true);
            document.querySelector('.character.opponent').innerHTML = createCharacterHTML(gameState.opponentCharacter, false);
            
            generateHand();
            updateUI();
            updateDeckDisplay();
        }

        // Atualizar UI
        function updateUI() {
            // Atualizar vida do jogador (diminui da direita para esquerda)
            const playerHealthFill = document.getElementById('playerHealth');
            const playerHealthText = document.getElementById('playerHealthText');
            playerHealthFill.style.width = `${gameState.playerHealth}%`;
            playerHealthText.textContent = `${gameState.playerHealth}/100`;
            
            // Atualizar vida do oponente (diminui da esquerda para direita)
            const opponentHealthFill = document.getElementById('opponentHealth');
            const opponentHealthText = document.getElementById('opponentHealthText');
            opponentHealthFill.style.width = `${gameState.opponentHealth}%`;
            opponentHealthText.textContent = `${gameState.opponentHealth}/100`;
        }

        // Event listeners
        document.getElementById('playComboBtn').addEventListener('click', playCombo);
        document.getElementById('clearComboBtn').addEventListener('click', clearCombo);
        document.getElementById('newHandBtn').addEventListener('click', () => {
            // Verificar se h√° cartas no baralho
            if (gameState.deckCount <= 0) {
                alert('N√£o h√° cartas suficientes no baralho!');
                checkGameOver();
                return;
            }
            
            // Descartar m√£o atual e pegar novas cartas
            const cardsNeeded = 7;
            const cardsToAdd = Math.min(cardsNeeded, gameState.deckCount);
            
            // Limpar m√£o atual
            gameState.hand = [];
            
            // Diminuir contador do baralho
            gameState.deckCount -= cardsToAdd;
            
            // Gerar nova m√£o
            for (let i = 0; i < cardsToAdd; i++) {
                const leftSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                const rightSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                gameState.hand.push({
                    id: Date.now() + Math.random() + i,
                    leftSymbol: leftSymbol,
                    rightSymbol: rightSymbol,
                    text: getCardText(leftSymbol, rightSymbol)
                });
            }
            
            renderHand();
            updateDeckDisplay();
            
            // Verificar se ficou sem cartas ap√≥s pegar nova m√£o
            checkGameOver();
        });

        // Inicializar
        initGame();
    </script>
</body>
</html>